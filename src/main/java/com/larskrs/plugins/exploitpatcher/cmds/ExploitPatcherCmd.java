package com.larskrs.plugins.exploitpatcher.cmds;

import com.larskrs.plugins.exploitpatcher.EntityListMenu;
import com.larskrs.plugins.exploitpatcher.ExploitPatcher;
import com.larskrs.plugins.exploitpatcher.config;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.World;
import org.bukkit.command.*;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ExploitPatcherCmd implements CommandExecutor, TabCompleter {
    private ExploitPatcher exploitPatcher;
    private ArrayList<String> args0;


    public ExploitPatcherCmd(ExploitPatcher exploitPatcher) {
        args0 = new ArrayList<String>();
        args0.add("banEntity");
        args0.add("removeBannedEntities");
        args0.add("help");


        this.exploitPatcher = exploitPatcher;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {

        Player p = (Player) sender;

        if (args.length < 1) {
            displayHelpMenu(p);
            return false;
        }
        if (args[0].equalsIgnoreCase("banEntity")) {
            // Adding entity
            new EntityListMenu(p, 1);
        } else if (args[0].equalsIgnoreCase("removeBannedEntities")) {
            // Adding entity
            removeBannedEntities(p, args);
        }

        return false;
    }

    public void displayHelpMenu(Player p) {

        //Loop through all available (custom) plugins

        // Loop through all the available commands of those plugins
        for (String commands : Bukkit.getPluginManager().getPlugin(exploitPatcher.getName()).getDescription().getCommands().keySet())
            p.sendMessage(ChatColor.translateAlternateColorCodes('&', "&c/" + commands + " - &f" + Bukkit.getPluginManager().getPlugin(exploitPatcher.getName()).getDescription().getCommands().get(commands).get("description")));
        {

            //Get the description of the command
        }


        p.sendMessage(ChatColor.translateAlternateColorCodes('&', "&cCorrect usage: /ep"));
    }


    public void unBanEntity(Player p, String[] args) {

        FileConfiguration confg = exploitPatcher.getConfig();

        try {
            EntityType entType = EntityType.valueOf(args[1].toUpperCase());
        } catch (IllegalArgumentException exp) {
            p.sendMessage(ChatColor.translateAlternateColorCodes('&', "&c" + args[1].toUpperCase() + " is not a valid entity type."));
            return;
        }


        List<String> blocked = confg.getStringList("blocked-entities");
        if (blocked.contains(args[1].toUpperCase())) {
            p.sendMessage( ChatColor.translateAlternateColorCodes('&', "&f" + args[1].toUpperCase() + " &ais no longer banned!"));
            config.unbanEntity(args[1]);
        } else {
            p.sendMessage(ChatColor.translateAlternateColorCodes('&', "&f" + args[1].toUpperCase() + " &cis not banned."));

        }

    }

    public void removeBannedEntities(Player p, String[] args) {

        FileConfiguration confg = exploitPatcher.getConfig();

        List<String> blocked = confg.getStringList("blocked-entities");
        int killed = 0;
        for (World w : Bukkit.getServer().getWorlds()) {
            for (Entity e : w.getEntities()) {
                if (e instanceof LivingEntity && blocked.contains(e.getType().name())) {
                    LivingEntity el = (LivingEntity) e;

                    el.damage(el.getHealth());


                    killed++;
                }
            }
        }
        p.sendMessage(ChatColor.translateAlternateColorCodes('&', "&fRemoved: "+ killed + " entities."));

    }

    @Override
    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {

        List<String> autoCompletes = new ArrayList<String>();
        if (args.length == 1) {

            for (String s : args0) {
                if (s.toLowerCase().startsWith(args[0].toLowerCase())) {
                    autoCompletes.add(s);

                }
            }
        }
            Collections.sort(autoCompletes);

            return autoCompletes;
        }

    }

